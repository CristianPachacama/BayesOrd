\name{bayesord}
\alias{bayesord}
\alias{bayesord.default}
\alias{print.bayesord}
\title{MCMC routines for fitting ordinal regression models in a Bayesian framework}
\description{
Fits proportional odds (PO) and non-proportional odds 
ordinal regression models using MCMC. The function also provides a means to perform Bayesian model selection based on posterior probabilities of association, that allows the model to select between PO and NPO
structures for each variable. In addition variable selection can be incorporated. The underlying code
is based on reversible-jump Markov chain Monte Carlo (MCMC), and details can be found in McKinley et al.,
(2014).
}
\usage{
bayesord(formula, ...)

\method{bayesord}{default}(formula, data = list(), nchains = 1, multi = F, 
    model.type = c("PO", "NPO", "both"), var.select = FALSE,
    niter = 50000, noutputsum = 1000, mnb = 0, varb = 1000, 
    maxsdb = 20, fixed = FALSE, vart = 1, mnpsi = 0, shvarp = 0.01, 
    rtvarp = 0.01, propsdb = 1, proptaut = 1, proptaup = 1, 
    proptauvarp = 1, runtraining = FALSE, nitertrain = 1000, 
    start = NA, end = NA, thin = NA, ...)

\method{print}{bayesord}(x, ...)
}
\arguments{
  \item{formula}{an object of class "formula": a symbolic description of the model to be
        fitted.  The details of model specification are given under 'Details'.}
  \item{x}{an object of class "bayesord".}
  \item{data}{a 'data.frame' object containg the data.}
  \item{nchains}{an integer defining the number of chains to be run.}
  \item{multi}{a logical specifying whether to run the code in parallel.}
  \item{model.type}{a character specifying the type of model to be fitted (\code{both} in this case corresponds to using model selection to choose between PO and NPO structures for each variable).}
  \item{var.select}{a logical specifying whether variable selection should be used.}
  \item{niter}{an integer specifying the number of iterations of the MCMC per chain.}
  \item{noutputsum}{an integer specifying how often to print output summaries to screen during model runs.}
  \item{mnb}{a numeric scalar corresponding to prior mean for regression parameters.}
  \item{varb}{a numeric scalar corresponding to prior variance for regression parameters if using a fixed prior.}
  \item{maxsdb}{a numeric scalar corresponding to maximum value for standard deviation hyperparameter on the regression parameters if not using a fixed prior.}
  \item{fixed}{a logical specifying whether a fixed prior is to be used for the regression parameters.}
  \item{vart}{a numeric scalar corresponding to prior variance for threshold parameters.}
  \item{mnpsi}{a numeric scalar corresponding to prior mean for clustering terms.}
  \item{shvarp}{a numeric scalar corresponding to shape parameter for gamma hyperprior on variance for clustering terms.}
  \item{rtvarp}{a numeric scalar corresponding to rate parameter for gamma hyperprior on variance for clustering terms.}
  \item{propsdb}{a numeric scalar corresponding to standard deviation of Gaussian random-walk proposals for regression parameters.}
  \item{proptaut}{a numeric scalar corresponding to the maximum jump size for uniform random-walk proposals for threshold parameters.}
  \item{proptaup}{a numeric scalar corresponding to the maximum jump size for uniform random-walk proposals for clustering parameters.}
  \item{proptauvarp}{a numeric scalar corresponding to the maximum jump size for uniform random-walk proposals for the variance of the clustering parameters.}
  \item{runtraining}{a logical specifying whether a training run is required (can sometimes help with identifiability in NPO models).}
  \item{nitertrain}{an integer specifying how many iterations required for training.}
  \item{start}{an integer specifying the length of the burn-in period if only a subset of the samples are to be returned.}
  \item{end}{an integer specifying the final iteration to be returned.}
  \item{thin}{an integer specifying the thinning rate of the chain.}
  \item{\dots}{not used here.}
}
\details{
Full details of the methodology is provided in McKinley et al. (2014). 

In order for the \code{multi} argument to be used, the \code{multicore} package must be installed. This simply runs each chain in parallel, so the number of cores is set to the number of chains, or the maximum number of cores, whichever is smaller.

As well as \code{print}, there are also \code{summary}, \code{plot}, \code{window} and \code{fitted} methods for "bayesord" objects.
}
\value{
Produces a list with elements:
\item{beta}{a list of length \code{nchains}, where each element of the list contains a matrix of posterior samples for the regression parameters generated by that chain.}
\item{theta}{a list of length \code{nchains}, where each element of the list contains a matrix of posterior samples for the threshold parameters generated by that chain.}
\item{status}{a list of length \code{nchains}, where each element of the list contains a matrix of posterior samples for the structure (or inclusion/exclusion) of each rgeression parameter generated by that chain. If no model or variable selection was used, then this defaults to \code{NA}.}
\item{psi}{a list of length \code{nchains}, where each element of the list contains a matrix of posterior samples for the clustering parameters generated by that chain. If no clustering was used, then this defaults to \code{NA}.}
\item{sdb}{a list of length \code{nchains}, where each element of the list contains a matrix of posterior samples for the standard deviation hyperparameters, corresponding to each regression parameter, generated by that chain. If a fixed prior was used, then this defaults to \code{NA}.}
\item{varp}{a list of length \code{nchains}, where each element of the list contains a matrix of posterior samples for the variance of the clustering parameters generated by that chain. If no clustering was used, then this defaults to \code{NA}.}
\item{loglikelihood}{a list of length \code{nchains}, where each element of the list contains a vector of log-likelihoods from each posterior sample generated by that chain.}
\item{info}{a data frame containing information about the model and MCMC runs.}
\item{model.dat}{a data frame where each row corresponds to a unique configuration of data points (effectively a condensed version of the original data, used for improving efficiency).}
\item{var.info}{a list, containing information relating to the original data. This is used to produce the marginal plots.}
\item{call}{the original model call.}
\item{formula}{a formula object containing a symbolic description of the model.}
}
\references{McKinley et al, (2014), to appear in Bayesian Analysis.}
\author{TJ McKinley}
\seealso{\code{\link{summary.bayesord}}, \code{\link{plot.bayesord}}, \code{\link{fitted.bayesord}}}
\examples{
# load in US data on religious fundamentalism against region of residence
# (data can be found in Agresti, "Analysis of Ordinal Categorical Data", (2010))
data(religion)

# run proportional odds model
# (if 'multicore' package is installed, then the 'multi = TRUE' argument
# enables chains to be run in parallel)
religion.PO <- bayesord(Beliefs ~ Region, data = religion, niter = 2e+05, noutputsum = 2e+04, 
    nchains = 2)
# draw trace plots for regression parameters (add 'ask = TRUE' to pause plots)
plot(religion.PO)
# discard burnin and thin the output to return 2000 samples
religion.PO <- window(religion.PO, start = 50000, thin = 150)
# summarise output
print(religion.PO)
summary(religion.PO)
# produce predictive posterior samples for the observed data
# (if 'multicore' package is installed, then the 'multi = TRUE' argument
# enables code to run in parallel)
fitted.PO <- fitted(religion.PO)
# summarise and plot predictive posteriors
print(fitted.PO)
plot(fitted.PO)

# fit non-proportional odds model
religion.NPO <- bayesord(Beliefs ~ Region, data = religion, niter = 2e+05, noutputsum = 2e+04, 
    nchains = 2, model.type = "NPO", start = 50000, thin = 150)
# check convergence plots and summarise output
plot(religion.NPO)
print(religion.NPO)
summary(religion.NPO)
# examine fitted model
fitted.NPO <- fitted(religion.NPO)
# summarise and plot predictive posteriors
print(fitted.NPO)
plot(fitted.NPO)

# allow model to choose between PO and NPO structures
religion.both <- bayesord(Beliefs ~ Region, data = religion, niter = 2e+05, 
    noutputsum = 2e+04, nchains = 2, model.type = "both", start = 50000, thin = 150)
# check convergence plots and summarise output
plot(religion.both)
print(religion.both)
summary(religion.both)
# predictive posteriors can be produced and checked as before

# load data on mental health against life events and socio-economic status
# (data can be found in Agresti, "Analysis of Ordinal Categorical Data", (2010))
data(mentalhealth)
# run a model with variable selection, allowing the model to choose between 
# PO and NPO structures for each variable
mentalhealth.VS <- bayesord(Mental.Health ~ SES + Life.Event, data = mentalhealth, niter = 5e+05, noutputsum = 5e+04, nchains = 2, model.type = "both", var.select = TRUE, start = 50000, thin = 450)
# check convergence plots and summarise output
plot(mentalhealth.VS)
print(mentalhealth.VS)
summary(mentalhealth.VS)
# predictive posteriors
fits.mentalhealth <- fitted(mentalhealth.VS)
print(fits.mentalhealth)
plot(fits.mentalhealth)
}
